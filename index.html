<!--
  This HTML file contains everything needed to interactively train, test, and explore a Convolutional Neural Network (CNN)
  in the browser, including:
  - Controls for designing the network,
  - Ways to input image data,
  - A simple CNN implemented in JavaScript (inside <script> tags)
  - Visual feedback for predictions and training
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Convolutional Neural Network Trainer</title>
    <!-- Styling for the form and visuals, to make the page readable and organized -->
    <style>
        body { font-family: Arial, sans-serif; margin: 2rem; }
        .section { margin-bottom: 2rem; border-bottom: 1px solid #ccc; padding-bottom: 1rem; }
        label { display: block; margin-top: 0.5rem; }
        input, select, textarea, button { margin: 0.5rem 0; }
        .metric { font-weight: bold; }
        .results { background-color: #f5f5f5; padding: 1rem; margin: 1rem 0; border-radius: 5px; }
        table { border-collapse: collapse; width: 100%; margin: 1rem 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .epoch-info { font-style: italic; color: #666; margin-top: 0.5rem; }
    </style>
</head>
<body>
<h1>Convolutional Neural Network Trainer</h1>

<!-- Section 1: CNN Configuration, lets user choose network layout -->
<div class="section">
    <h2>CNN Configuration</h2>
    <label>Image Width: <input type="number" id="imgWidth" value="28" min="1"></label>
    <label>Image Height: <input type="number" id="imgHeight" value="28" min="1"></label>
    <label>Channels: <input type="number" id="imgChannels" value="1" min="1" max="3"></label>
    <br>
    <label>Convolution Filters (comma separated): <input type="text" id="convFilters" value="16,32"></label>
    <label>Convolution Kernel Sizes (comma separated): <input type="text" id="kernelSizes" value="3,3"></label>
    <label>Pooling Sizes (comma separated): <input type="text" id="poolSizes" value="2,2"></label>
    <label>Fully Connected Sizes (comma separated): <input type="text" id="fcSizes" value="128"></label>
    <label>Output Size / Classes: <input type="number" id="outputSize" value="10" min="1"></label>
    <label>Learning Rate: <input type="number" id="learningRate" value="0.01" step="0.001" min="0.001" max="1"></label>
    <button onclick="createNetwork()">Create Network</button>
    <span id="networkStatus"></span>
</div>

<!-- Section 2: Enter image data as CSV or random -->
<div class="section">
    <h2>Image Data</h2>
    <label>Randomize Sample Image</label>
    <button onclick="randomizeImage()">Randomize Image</button>
    <label>Or edit CSV:</label>
    <textarea id="imageCSV" rows="8" cols="60" placeholder="Paste CSV (channels,height,width)"></textarea>
    <button onclick="loadImage()">Load CSV as Image</button>
    <div id="imageStatus"></div>
</div>

<!-- Section 3: Specify the output target (what label is this image?) -->
<div class="section">
    <h2>Target Class</h2>
    <label>Target Vector (comma separated, e.g. 1,0,0... for class 0): <input type="text" id="targetVec" value="1,0,0,0,0,0,0,0,0,0"></label>
</div>

<!-- Section 4: Train/Test Controls -->
<div class="section">
    <h2>Train & Predict</h2>
    <label>Train Epochs: <input type="number" id="trainEpochs" value="10" min="1" max="100"></label>
    <button onclick="trainNetwork()">Train Network</button>
    <span id="trainStatus"></span>
    <br>
    <button onclick="predictImage()">Predict</button>
    <div id="predictionResult"></div>
</div>

<!-- 
  The main code section: JavaScript CNN logic!
  Everything below here is code that powers the neural network, data processing, and UI updates.
-->
<script>
class CNN {
    /**
     * Build a CNN with user-specified layer parameters.
     */
    constructor(inputWidth, inputHeight, channels, convFilters, kernelSizes, poolSizes, fcSizes, outputSize, learningRate) {
        this.inputWidth = inputWidth;
        this.inputHeight = inputHeight;
        this.channels = channels;
        this.convFilters = convFilters;
        this.kernelSizes = kernelSizes;
        this.poolSizes = poolSizes;
        this.fcSizes = fcSizes;
        this.outputSize = outputSize;
        this.learningRate = learningRate;
        this.initLayers();
    }

    /**
     * Initializes convolutional, pooling, fully connected, and output layers.
     */
    initLayers() {
        this.convLayers = [];
        this.poolLayers = [];
        let currWidth = this.inputWidth;
        let currHeight = this.inputHeight;
        let currChannels = this.channels;
        for (let i = 0; i < this.convFilters.length; i++) {
            let kernel = this.kernelSizes[i];
            let filters = this.convFilters[i];
            this.convLayers.push(this.initConvLayer(filters, currChannels, kernel));
            // Calculate output size after this conv layer
            currWidth = Math.floor((currWidth - kernel + 2 * 1) / 1 + 1); // padding=1, stride=1
            currHeight = Math.floor((currHeight - kernel + 2 * 1) / 1 + 1);
            currChannels = filters;
            if (i < this.poolSizes.length) {
                let pool = this.poolSizes[i];
                this.poolLayers.push(this.initPoolLayer(pool));
                currWidth = Math.floor(currWidth / pool);
                currHeight = Math.floor(currHeight / pool);
            }
        }
        this.flattenedSize = currWidth * currHeight * currChannels;

        // Setup fully connected layers
        this.fcLayers = [];
        let numInputs = this.flattenedSize;
        for (let sz of this.fcSizes) {
            this.fcLayers.push(this.initFCLayer(sz, numInputs));
            numInputs = sz;
        }
        // Output layer (final predictions)
        this.outputLayer = this.initFCLayer(this.outputSize, numInputs);
    }

    /**
     * Initializes a single convolutional layer. 
     * Each filter is a set of random weights and a bias.
     */
    initConvLayer(numFilters, inChannels, kernel) {
        let filters = [];
        for (let i = 0; i < numFilters; i++) {
            let w = [];
            for (let c = 0; c < inChannels; c++) {
                let k = [];
                for (let h = 0; h < kernel; h++) {
                    let row = [];
                    for (let wIdx = 0; wIdx < kernel; wIdx++) {
                        // He initialization: random weights for learning
                        row.push((Math.random() - 0.5) * Math.sqrt(2 / (inChannels * kernel * kernel)));
                    }
                    k.push(row);
                }
                w.push(k);
            }
            filters.push({ weights: w, bias: 0 });
        }
        return { filters, stride: 1, padding: 1, output: null };
    }

    /** 
     * Initializes a pooling layer (downsamples features to reduce size)
     */
    initPoolLayer(poolSize) {
        return { poolSize, output: null };
    }

    /**
     * Initializes a fully-connected layer.
     * Each neuron contains weights for its inputs and a bias.
     */
    initFCLayer(numNeurons, numInputs) {
        let neurons = [];
        for (let i = 0; i < numNeurons; i++) {
            let weights = [];
            for (let j = 0; j < numInputs; j++)
                weights.push((Math.random() - 0.5) * 0.1);
            neurons.push({ weights, bias: 0, output: 0, error: 0 });
        }
        return { neurons };
    }

    /** Rectified Linear Unit activation (ReLU) function */
    relu(x) { return Math.max(0, x); }
    /** Derivative of ReLU (used in training/backprop) */
    reluD(x) { return x > 0 ? 1 : 0; }
    /** Sigmoid activation function (squashes values to range [0,1]) */
    sigmoid(x) { return 1 / (1 + Math.exp(-x)); }

    /**
     * Forward pass for convolutional layer: applies filters to input array
     */
    convForward(layer, input, inWidth, inHeight) {
        let outputMaps = [];
        let inChannels = input.length;
        let kernel = layer.filters[0].weights[0].length;
        let outWidth = Math.floor((inWidth - kernel + 2 * layer.padding) / layer.stride + 1);
        let outHeight = Math.floor((inHeight - kernel + 2 * layer.padding) / layer.stride + 1);
        for (let f = 0; f < layer.filters.length; f++) {
            let map = [];
            for (let h = 0; h < outHeight; h++) {
                let row = [];
                for (let w = 0; w < outWidth; w++) {
                    let sum = layer.filters[f].bias;
                    for (let c = 0; c < inChannels; c++) {
                        for (let kh = 0; kh < kernel; kh++) {
                            for (let kw = 0; kw < kernel; kw++) {
                                let inH = h * layer.stride + kh;
                                let inW = w * layer.stride + kw;
                                if (inH < inHeight && inW < inWidth)
                                    sum += input[c][inH][inW] * layer.filters[f].weights[c][kh][kw];
                            }
                        }
                    }
                    row.push(this.relu(sum));
                }
                map.push(row);
            }
            outputMaps.push(map);
        }
        layer.output = outputMaps;
        return outputMaps;
    }

    /**
     * Forward pass for pooling layer: downsamples feature maps, keeps largest value in each region
     */
    poolForward(layer, input, inWidth, inHeight) {
        let outputMaps = [];
        let outWidth = Math.floor(inWidth / layer.poolSize);
        let outHeight = Math.floor(inHeight / layer.poolSize);
        for (let c = 0; c < input.length; c++) {
            let map = [];
            for (let h = 0; h < outHeight; h++) {
                let row = [];
                for (let w = 0; w < outWidth; w++) {
                    let maxVal = -Infinity;
                    for (let ph = 0; ph < layer.poolSize; ph++) {
                        for (let pw = 0; pw < layer.poolSize; pw++) {
                            let v = input[c][h * layer.poolSize + ph][w * layer.poolSize + pw];
                            if (v > maxVal) maxVal = v;
                        }
                    }
                    row.push(maxVal);
                }
                map.push(row);
            }
            outputMaps.push(map);
        }
        layer.output = outputMaps;
        return outputMaps;
    }

    /** Flattens multi-dimensional feature maps into a 1D array */
    flattenFeatures(input) {
        let arr = [];
        for (let c = 0; c < input.length; c++)
            for (let h = 0; h < input[c].length; h++)
                for (let w = 0; w < input[c][h].length; w++)
                    arr.push(input[c][h][w]);
        this.flattenedFeatures = arr;
        return arr;
    }

    /**
     * Forward pass for fully connected (FC) layer: calculates neuron outputs for each layer
     */
    fcForward(layer, input) {
        let outputs = [];
        for (let n of layer.neurons) {
            let sum = n.bias;
            for (let j = 0; j < input.length; j++)
                sum += input[j] * n.weights[j];
            n.output = this.relu(sum);
            outputs.push(n.output);
        }
        return outputs;
    }

    /**
     * Predicts class probabilities for an image object using the full forward pass through the model
     */
    predictImage(imageObj) {
        let { data, width, height, channels } = imageObj;
        // Forward through conv/pool layers
        let currentOutput = data;
        let currWidth = width, currHeight = height;
        for (let i = 0; i < this.convLayers.length; i++) {
            currentOutput = this.convForward(this.convLayers[i], currentOutput, currWidth, currHeight);
            currWidth = currentOutput[0][0].length;
            currHeight = currentOutput[0].length;
            if (i < this.poolLayers.length) {
                currentOutput = this.poolForward(this.poolLayers[i], currentOutput, currWidth, currHeight);
                currWidth = currentOutput[0][0].length;
                currHeight = currentOutput[0].length;
            }
        }
        let flat = this.flattenFeatures(currentOutput);
        let layerInput = flat;
        for (let fcl of this.fcLayers)
            layerInput = this.fcForward(fcl, layerInput);
        // Output layer
        let result = [];
        for (let n of this.outputLayer.neurons) {
            let sum = n.bias;
            for (let j = 0; j < layerInput.length; j++)
                sum += layerInput[j] * n.weights[j];
            let o = this.sigmoid(sum);
            n.output = o;
            result.push(o);
        }
        return result;
    }

    /**
     * Trains the network using a single image and its target vector.
     * Only output layer weights are updated for brevity
     */
    train(imageObj, targetVec) {
        let pred = this.predictImage(imageObj);
        let out = this.outputLayer.neurons;
        for (let i = 0; i < out.length; i++)
            // Calculate error using sigmoid derivative
            out[i].error = out[i].output * (1 - out[i].output) * (targetVec[i] - out[i].output);
        // Update output weights using backprop
        let flat = this.flattenedFeatures;
        for (let i = 0; i < out.length; i++) {
            for (let j = 0; j < out[i].weights.length; j++)
                out[i].weights[j] += this.learningRate * out[i].error * flat[j];
            out[i].bias += this.learningRate * out[i].error;
        }
    }
}

/** ========= Utility & UI Functions ========== **/

// Converts CSV text into structured image data
function parseImageCSV(csv, ch, h, w) {
    let arr = [];
    let lines = csv.trim().split("\n");
    let idx = 0;
    for (let c = 0; c < ch; c++) {
        let chan = [];
        for (let i = 0; i < h; i++) {
            let vals = lines[idx].split(',').map(Number);
            if (vals.length != w) throw "Wrong width in image data CSV!";
            chan.push(vals);
            idx++;
        }
        arr.push(chan);
    }
    return arr;
}

// Creates a random image for input and testing
function randomImage(ch, h, w) {
    let d = [];
    for (let c = 0; c < ch; c++) {
        let chan = [];
        for (let i = 0; i < h; i++) {
            let row = [];
            for (let j = 0; j < w; j++)
                row.push(Number(Math.random().toFixed(4)));
            chan.push(row);
        }
        d.push(chan);
    }
    return d;
}

/** Stores global CNN instance and sample image definitions for UI */
let cnn = null;
let sampleImage = {
    data: randomImage(
        +document.getElementById("imgChannels").value,
        +document.getElementById("imgHeight").value,
        +document.getElementById("imgWidth").value
    ),
    width: +document.getElementById("imgWidth").value,
    height: +document.getElementById("imgHeight").value,
    channels: +document.getElementById("imgChannels").value
};

/** Creates a new CNN instance using form input values */
function createNetwork() {
    let w = +document.getElementById("imgWidth").value;
    let h = +document.getElementById("imgHeight").value;
    let ch = +document.getElementById("imgChannels").value;
    let convFilters = document.getElementById("convFilters").value.split(',').map(x=>+x.trim());
    let kernelSizes = document.getElementById("kernelSizes").value.split(',').map(x=>+x.trim());
    let poolSizes = document.getElementById("poolSizes").value.split(',').map(x=>+x.trim());
    let fcSizes = document.getElementById("fcSizes").value.split(',').map(x=>+x.trim());
    let outputSize = +document.getElementById("outputSize").value;
    let lr = +document.getElementById("learningRate").value;
    cnn = new CNN(w, h, ch, convFilters, kernelSizes, poolSizes, fcSizes, outputSize, lr);
    document.getElementById("networkStatus").textContent = "CNN created!";
}

/** Generates random image data and displays as CSV */
function randomizeImage() {
    let w = +document.getElementById("imgWidth").value;
    let h = +document.getElementById("imgHeight").value;
    let ch = +document.getElementById("imgChannels").value;
    sampleImage = { data: randomImage(ch, h, w), width: w, height: h, channels: ch };
    // Set textarea value to generated CSV for user viewing/editing
    let csv = '';
    for (let c = 0; c < ch; c++) {
        for (let i = 0; i < h; i++) {
            csv += sampleImage.data[c][i].join(',') + '\n';
        }
    }
    document.getElementById("imageCSV").value = csv.trim();
    document.getElementById("imageStatus").textContent = "Random image generated!";
}

/** Loads image data from user-edited CSV and sets up the image object */
function loadImage() {
    let w = +document.getElementById("imgWidth").value;
    let h = +document.getElementById("imgHeight").value;
    let ch = +document.getElementById("imgChannels").value;
    let csv = document.getElementById("imageCSV").value;
    try {
        let arr = parseImageCSV(csv, ch, h, w);
        sampleImage = { data: arr, width: w, height: h, channels: ch };
        document.getElementById("imageStatus").textContent = "Image loaded from CSV!";
    } catch(e) {
        document.getElementById("imageStatus").textContent = "Error: " + e;
    }
}

/** Trains the network for the specified number of epochs using the current image and target vector */
function trainNetwork() {
    if (!cnn) return;
    let epochs = +document.getElementById("trainEpochs").value;
    let target = document.getElementById("targetVec").value.split(',').map(Number);
    for (let ep = 0; ep < epochs; ep++)
        cnn.train(sampleImage, target);
    document.getElementById("trainStatus").textContent = "Training complete ("+epochs+" epochs)";
}

/** Makes a prediction from the current image and displays the results */
function predictImage() {
    if (!cnn) return;
    let pred = cnn.predictImage(sampleImage);
    document.getElementById("predictionResult").innerHTML =
        "<div class='metric'>Predicted: [" + pred.map(x=>x.toFixed(4)).join(", ") + "]</div>";
}

// On page load, create a random image so user gets a prompt
randomizeImage();

</script>
</body>
</html>
